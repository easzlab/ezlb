### ezlb-ipvs-tcp-load-balancer ###
使用 Go 语言和 IPVS 实现一个四层 TCP 负载均衡工具，支持 YAML 配置文件管理、RR/WRR/LC 负载均衡算法、TCP 健康检查，采用声明式 Reconcile 模式动态调整 IPVS 服务，支持 systemd 服务和命令行手动触发。先实现 TCP 协议支持，架构上预留 UDP 扩展能力。


## 项目结构

```
ezlb/
├── cmd/
│   └── ezlb/
│       └── main.go
├── pkg/
│   ├── config/
│   │   └── config.go
│   ├── lvs/
│   │   ├── manager.go
│   │   ├── reconciler.go
│   │   └── types.go
│   ├── healthcheck/
│   │   ├── checker.go
│   │   └── manager.go
│   └── server/
│       └── server.go
├── examples/
│   └── ezlb.yaml
├── deploy/
│   └── ezlb.service
├── Makefile
├── go.mod
└── go.sum
```

## 核心依赖

| 依赖 | 用途 |
|------|------|
| `github.com/moby/ipvs` | IPVS netlink 操作 |
| `github.com/spf13/viper` | YAML 配置解析、环境变量、热加载 |
| `github.com/spf13/cobra` | CLI 命令行构建 |
| `go.uber.org/zap` | 高性能结构化日志 |

---

## 模块处理逻辑

---

### 模块 1：配置管理模块 (config)

**职责**：配置文件的加载、校验和热加载通知

**处理逻辑**：

1. **首次加载**：启动时读取 YAML 配置文件，反序列化为内部结构，执行校验。校验失败则启动中止。

2. **热加载**：利用 viper 的 WatchConfig 能力监听配置文件变更。文件变更后重新加载并校验，校验通过则更新内部配置并向 onChange channel 发送通知；校验失败则仅记录错误日志，保留旧配置不变。

3. **对外暴露**：
   - 提供获取当前配置快照的方法（加读锁保证并发安全）
   - 提供只读 channel 供外部监听配置变更事件

4. **协议配置**：每个 service 支持 `protocol` 字段，当前仅实现 `tcp`，默认值为 `tcp`。校验时若遇到不支持的协议值则报错。后续扩展 UDP 时只需在校验中增加 `udp` 取值即可。

5. **健康检查配置**：每个 service 独立定义健康检查参数，支持 `enabled` 字段控制是否启用，默认为 true。

6. **校验规则**：地址格式、调度器取值（rr/wrr/lc）、权重正整数、服务名唯一性、协议取值、健康检查参数合法性。

**示例配置**：

```yaml
global:
  log_level: info

services:
  - name: web-service
    listen: 10.0.0.1:80
    protocol: tcp              # 当前仅支持 tcp，默认值 tcp
    scheduler: wrr
    health_check:
      enabled: true
      interval: 5s
      timeout: 3s
      fail_count: 3
      rise_count: 2
    backends:
      - address: 192.168.1.10:8080
        weight: 5
      - address: 192.168.1.11:8080
        weight: 3

  - name: internal-service
    listen: 10.0.0.2:9090
    scheduler: rr
    health_check:
      enabled: false
    backends:
      - address: 192.168.3.10:9090
        weight: 1
```

---

### 模块 2：IPVS 管理模块 (lvs)

**职责**：封装 IPVS 内核操作 + 声明式 Reconcile

该模块内部分为两个角色：**Manager（执行者）** 和 **Reconciler（决策者）**。

#### Manager（执行者）

对 `moby/ipvs` 库的薄封装，提供 IPVS 虚拟服务和真实服务器的 CRUD 操作，每个操作附带日志记录。Manager 本身不做任何决策，只负责执行指令。

#### 类型转换 (types)

负责配置结构体到 IPVS 结构体的转换。根据配置中的 `protocol` 字段映射到对应的 IPVS 协议常量（tcp -> syscall.IPPROTO_TCP）。后续扩展 UDP 时在此处增加 udp -> syscall.IPPROTO_UDP 的映射即可。

#### Reconciler（决策者）

**Reconcile 流程**：

1. **构建期望状态**：遍历配置中的所有 service，转换为 IPVS 虚拟服务和真实服务器。对于每个 backend：
   - 若该 service 启用了健康检查：查询健康状态，不健康的 backend 直接从期望状态中剔除
   - 若该 service 禁用了健康检查：所有 backend 均视为健康，全部保留

2. **获取实际状态**：从 IPVS 内核读取当前所有虚拟服务及其真实服务器列表，过滤出由 ezlb 管理的服务。

3. **Service 层 Diff**：
   - 期望有、实际无 -> 创建虚拟服务
   - 期望有、实际有但调度算法不同 -> 更新虚拟服务
   - 期望无、实际有（且属于 ezlb 管理） -> 删除虚拟服务

4. **Destination 层 Diff**（对每个虚拟服务）：
   - 期望有、实际无 -> 添加真实服务器
   - 期望有、实际有但 weight 不同 -> 更新真实服务器
   - 期望无、实际有 -> 移除真实服务器

5. **错误处理**：单个操作失败不中断整体 Reconcile，收集所有错误最终返回聚合错误。

---

### 模块 3：健康检查模块 (healthcheck)

**职责**：定期探测后端服务器的可用性，维护健康状态

**处理逻辑**：

1. **TCP 探测**：对目标地址发起 TCP 连接，连接成功即健康，失败或超时即不健康。后续扩展 UDP 时，可新增 UDP 探测器实现（如发送探测包等），通过接口抽象实现探测方式的可扩展。

2. **状态判定**（每个 backend 独立维护）：
   - 连续失败达到 `fail_count` 阈值 -> 标记为不健康
   - 连续成功达到 `rise_count` 阈值 -> 标记为健康

3. **按 service 维度管理**：每个 service 下的 backends 共享该 service 的健康检查参数，不同 service 可以有不同的检查频率和判定策略。

4. **禁用健康检查的 service**：不创建检查 goroutine，不维护状态。外部查询时一律返回健康。

5. **动态目标管理**：配置变更时动态增减检查目标，处理健康检查启用/禁用的变更。

6. **状态变更通知**：健康状态变化时调用 onChange 回调触发 Reconcile。

7. **扩展设计**：将探测逻辑抽象为接口（Checker），当前仅实现 TCPChecker。后续扩展 UDP 时新增 UDPChecker 实现该接口，根据 service 的 protocol 字段选择对应的 Checker。

---

### 模块 4：服务管理模块 (server)

**职责**：协调所有模块，管理整体生命周期

**处理逻辑**：

1. **初始化阶段**：按依赖顺序创建各模块实例，建立模块间的引用关系。

2. **守护进程模式（Run）**：
   - 注册启用了健康检查的 service 的 backends 到 healthcheck，启动健康检查
   - 执行首次 Reconcile
   - 启动配置文件热加载监听
   - 主循环等待事件：配置变更 -> 更新健康检查目标 + Reconcile；退出信号 -> 优雅退出

3. **单次模式（RunOnce）**：加载配置 -> 执行一次 Reconcile -> 关闭资源退出。

---

### 模块 5：命令行模块 (cmd)

**职责**：提供用户交互入口

- **根命令**：`--config` 参数 + SIGTERM/SIGINT 信号处理 + 守护进程模式
- **once 子命令**：单次 Reconcile 后退出
- **version 子命令**：打印版本号

---

## 模块联动关系

```
                    ┌──────────────┐
                    │   cmd (CLI)  │
                    │  解析参数     │
                    │  信号处理     │
                    └──────┬───────┘
                           │ 创建并启动
                           ▼
                    ┌──────────────┐
                    │   server     │
                    │  生命周期管理 │
                    │  事件循环     │
                    └──┬───┬───┬───┘
           ┌───────────┘   │   └───────────┐
           ▼               ▼               ▼
    ┌────────────┐  ┌────────────┐  ┌──────────────┐
    │   config   │  │ healthcheck│  │     lvs       │
    │  配置加载   │  │  健康探测   │  │ Manager       │
    │  热加载     │  │  状态维护   │  │ Reconciler    │
    └─────┬──────┘  └──────┬─────┘  └───┬──────┬───┘
          │                │            │      │
          │                │            │      │
          └────────────────┼────────────┘      │
                           │                   │
                           └───────────────────┘
```

### 联动流程

**流程 A - 启动时首次同步**：
1. cmd 创建 server
2. server 通过 config 加载配置
3. server 将启用了健康检查的 service 的 backends 注册到 healthcheck，启动健康检查
4. server 调用 lvs.Reconciler 执行首次 Reconcile
5. Reconciler 构建期望状态：启用健康检查的 service 剔除不健康 backend；禁用健康检查的 service 保留全部 backend
6. Reconciler 对比期望状态与 IPVS 内核实际状态，通过 lvs.Manager 执行变更

**流程 B - 配置热加载触发**：
1. config 检测到文件变更，重新加载并校验，通过 channel 通知 server
2. server 将新配置的 backends 更新到 healthcheck（增减检查目标，处理启用/禁用变更）
3. server 调用 lvs.Reconciler 执行 Reconcile

**流程 C - 健康状态变更触发**：
1. healthcheck 检测到某 backend 健康状态变化
2. healthcheck 调用 onChange 回调通知 server
3. server 调用 lvs.Reconciler 执行 Reconcile
4. Reconciler 构建期望状态时剔除不健康 backend 或重新加入恢复的 backend
5. Reconciler 与 IPVS 内核 Diff 后执行变更

**流程 D - 优雅退出**：
1. cmd 收到 SIGTERM/SIGINT，取消 context
2. server 依次停止 healthcheck、关闭 lvs.Manager、刷新日志

---

## UDP 扩展预留点

后续扩展 UDP 支持时，需要修改的位置：

1. **config**：校验中增加 `udp` 为合法的 protocol 取值
2. **lvs/types.go**：增加 `udp` -> `syscall.IPPROTO_UDP` 的协议映射
3. **healthcheck/checker.go**：新增 UDPChecker 实现 Checker 接口
4. **healthcheck/manager.go**：根据 service 的 protocol 选择对应的 Checker

其余模块（lvs/manager、lvs/reconciler、server、cmd）无需修改。

---

## 实现顺序

1. `pkg/config/` - 配置解析、校验、热加载
2. `pkg/lvs/types.go` + `pkg/lvs/manager.go` - IPVS 操作封装 + 类型转换
3. `pkg/healthcheck/` - TCP 健康检查
4. `pkg/lvs/reconciler.go` - 声明式 Reconcile
5. `pkg/server/` - 主服务编排
6. `cmd/ezlb/` - CLI 入口
7. 部署文件 - systemd unit、示例配置、Makefile


updateAtTime: 2026/2/7 21:48:59

planId: 63e8e31e-c40d-45b7-91e9-c32aeb9f0778