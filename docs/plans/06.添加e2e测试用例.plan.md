### 添加e2e测试用例 ###
在项目中新增 e2e 测试目录和测试用例，通过编译并执行 ezlb 二进制（进程外方式）或直接调用 server.NewServer + RunOnce（进程内方式），验证完整的配置加载 -> IPVS 规则写入 -> 规则验证流程，仅在 Linux 上运行。


## 问题分析

项目当前有单元测试（config/lvs/healthcheck）和集成测试（server），但缺少从程序入口出发的端到端（e2e）测试。e2e 测试需要验证：配置文件 -> CLI 入口 -> IPVS 内核规则写入的完整链路。

e2e 测试只能在 Linux 上运行（需要真实 IPVS 内核模块 + root 权限）。

---

### 步骤 1: 创建 e2e 测试目录结构

新建 `tests/e2e/` 目录，所有 e2e 测试文件使用 `//go:build linux` build tag。

```
tests/e2e/
├── e2e_test.go              # 主测试文件，包含所有 e2e 用例
├── testmain_test.go          # TestMain，负责编译二进制、全局 IPVS Flush
└── helpers_test.go           # 辅助函数（写配置文件、读 IPVS 规则、断言等）
```

### 步骤 2: 实现 TestMain（`tests/e2e/testmain_test.go`）

- `//go:build linux`
- 在 `TestMain` 中：
  - 使用 `exec.Command("go", "build", "-o", tmpBinary, "./cmd/ezlb/")` 编译 ezlb 二进制到临时目录
  - 使用 `lvs.NewIPVSHandle("")` 创建 handle，执行 `Flush()` 清理残留 IPVS 规则
  - 运行所有测试 `m.Run()`
  - 测试结束后再次 `Flush()` 清理，删除临时二进制

### 步骤 3: 实现辅助函数（`tests/e2e/helpers_test.go`）

- `//go:build linux`
- `runEzlbOnce(t, configPath)`: 执行 `ezlb once -c configPath`，断言退出码为 0，返回 stdout/stderr
- `writeTestConfig(t, dir, yaml)`: 写入测试配置文件
- `getIPVSServices(t)`: 通过 `lvs.NewIPVSHandle` 获取当前所有 IPVS service
- `getIPVSDestinations(t, svc)`: 获取指定 service 的所有 destination
- `findServiceByAddress(services, ip, port)`: 按 IP:Port 查找 service
- `flushIPVS(t)`: 清理所有 IPVS 规则（每个测试前后调用）

### 步骤 4: 实现 e2e 测试用例（`tests/e2e/e2e_test.go`）

- `//go:build linux`

#### 用例 1: `TestE2E_OnceMode_SingleService`
- 写入包含 1 个 service、2 个 backend 的配置（health_check disabled）
- 执行 `ezlb once -c config.yaml`
- 验证 IPVS 中存在 1 个 service，scheduler 正确
- 验证该 service 下有 2 个 destination，weight 正确

#### 用例 2: `TestE2E_OnceMode_MultiService`
- 写入包含 3 个 service 的配置（不同 scheduler: rr/wrr/lc）
- 执行 `ezlb once`
- 验证 IPVS 中存在 3 个 service，各 scheduler 正确
- 验证每个 service 的 destination 数量和 weight 正确

#### 用例 3: `TestE2E_OnceMode_Idempotent`
- 写入配置，连续执行两次 `ezlb once`
- 验证第二次执行成功（退出码 0），IPVS 规则不变

#### 用例 4: `TestE2E_OnceMode_ConfigUpdate`
- 第一次执行 `ezlb once`（1 个 service，2 个 backend，scheduler=rr）
- 修改配置文件（改 scheduler 为 wrr，增加 1 个 backend）
- 第二次执行 `ezlb once`
- 验证 IPVS 规则已更新：scheduler 变为 wrr，destination 变为 3 个

#### 用例 5: `TestE2E_OnceMode_ServiceRemoval`
- 第一次执行 `ezlb once`（2 个 service）
- 修改配置文件（删除 1 个 service）
- 第二次执行 `ezlb once`
- 验证 IPVS 中只剩 1 个 service（注意：`once` 模式每次创建新 Reconciler，managed map 为空，需要确认此场景的行为是否符合预期，可能需要调整）

#### 用例 6: `TestE2E_OnceMode_InvalidConfig`
- 写入无效配置（如缺少 backends）
- 执行 `ezlb once`
- 验证退出码非 0，stderr 包含错误信息

#### 用例 7: `TestE2E_DaemonMode_GracefulShutdown`
- 后台启动 `ezlb -c config.yaml`（daemon 模式）
- 等待短暂时间让初始 reconcile 完成
- 验证 IPVS 规则已写入
- 发送 SIGTERM
- 验证进程正常退出（退出码 0）

#### 用例 8: `TestE2E_Version`
- 执行 `ezlb version`
- 验证输出包含 "ezlb version"

### 步骤 5: 更新 Makefile

在 `Makefile` 中新增 e2e 测试 target：

```makefile
# e2e tests require root on Linux
test-e2e:
	go test -count=1 -v -p 1 -tags linux ./tests/e2e/
```

### 步骤 6: 处理 `once` 模式下跨次执行的 Reconcile 行为

当前 `RunOnce()` 每次创建新的 `Server`（新的 `Reconciler`），`managed` map 为空，意味着第二次 `once` 不会删除第一次创建但第二次配置中不存在的 service。需要确认：
- 如果这是预期行为（`once` 模式只做增量），则用例 5 需要调整预期
- 如果需要 `once` 模式也能清理多余 service，则需要在 `Reconciler` 初始化时扫描现有 IPVS 规则来填充 `managed` map（这属于功能变更，不在本次 e2e 测试范围内，但需要在测试中体现这一行为）

---

## 变更文件清单

| 操作 | 文件 |
|------|------|
| 新建 | `tests/e2e/testmain_test.go` -- TestMain，编译二进制 + IPVS 全局清理 |
| 新建 | `tests/e2e/helpers_test.go` -- 辅助函数 |
| 新建 | `tests/e2e/e2e_test.go` -- 8 个 e2e 测试用例 |
| 修改 | `Makefile` -- 新增 `test-e2e` target |

## 注意事项

- 所有 e2e 测试文件使用 `//go:build linux`，macOS 上 `go test ./...` 会自动跳过
- 测试必须以 root 权限运行（`sudo go test ...`）
- 测试串行执行（`-p 1`），因为 IPVS 是全局内核资源
- 每个测试前后都 Flush IPVS 规则，确保测试隔离


updateAtTime: 2026/2/8 11:40:38

planId: f876ad11-0724-48cd-a6f6-5e6d3de0b40e