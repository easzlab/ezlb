### 为IPVS服务添加SNAT支持实现等效FullNAT ###
通过 service 配置中的可选字段 full_nat（默认 false）控制是否启用 FullNAT 模式，启用后使用 coreos/go-iptables 库按后端目标地址匹配添加 SNAT/MASQUERADE 规则，配合 IPVS NAT 模式实现等效 FullNAT。配置了 snat_ip 时使用 SNAT 指定源地址，未配置时使用 MASQUERADE。


## 背景

Linux 原生 IPVS 不支持 FullNAT。替代方案是 IPVS NAT（Masq）+ iptables SNAT：
- IPVS 继续使用 Masq 模式做 DNAT
- 通过 iptables POSTROUTING 链，按后端目标地址匹配，对转发流量做 SNAT

使用 `github.com/coreos/go-iptables` 库操作 iptables 规则（该库封装 iptables 命令行，在 iptables-nft 后端系统上天然兼容 nftables 内核）。

规则形式（按每个 backend 生成一条规则，不依赖 xt_ipvs 模块）：
- 配置了 `snat_ip`：`-d <backend_ip> -p <proto> --dport <backend_port> -j SNAT --to-source <snat_ip>`
- 未配置 `snat_ip`：`-d <backend_ip> -p <proto> --dport <backend_port> -j MASQUERADE`

使用自定义链 `EZLB-SNAT` 管理规则，在 POSTROUTING 中跳转到该链，便于声明式清理。

通过 service 配置中的 `full_nat` 字段（默认 false）按 service 粒度控制。

## 步骤 1：新增依赖

`go.mod` 新增 `github.com/coreos/go-iptables`

## 步骤 2：配置层 — 新增 full_nat 和 snat_ip 字段

**文件**: `pkg/config/config.go`

1. `ServiceConfig` 新增：
   - `FullNAT bool`（yaml/mapstructure: `full_nat`，默认 false）
   - `SnatIP string`（yaml/mapstructure: `snat_ip`）
2. `Validate` 中：
   - 若 `snat_ip` 非空，校验为合法 IP
   - 若 `snat_ip` 非空但 `full_nat` 为 false，报错提示需启用 `full_nat`

## 步骤 3：新增 iptables SNAT 管理模块

### 3.1 接口和数据结构

**新建文件**: `pkg/snat/snat.go`

- `SNATRule`：BackendIP、BackendPort、Protocol、SnatIP（空表示 MASQUERADE）
- `Manager` 接口：`Reconcile(desired []SNATRule) error`、`Cleanup() error`

### 3.2 Linux 真实实现

**新建文件**: `pkg/snat/manager_linux.go`（build tag `integration`）

使用 `coreos/go-iptables` 库操作 iptables，管理自定义链 `EZLB-SNAT`：
- `NewManager`：通过 `iptables.New()` 创建 handle，创建 `EZLB-SNAT` 链，在 nat 表 POSTROUTING 添加 `-j EZLB-SNAT` 跳转
- `Reconcile`：声明式对比期望与已管理规则集合，使用 `ipt.AppendUnique` / `ipt.Delete` 增删差异
- `Cleanup`：`ipt.ClearChain` 清空链、删除 POSTROUTING 跳转、`ipt.DeleteChain` 删除链

### 3.3 非 Linux fake 实现

**新建文件**: `pkg/snat/manager_fake.go`（build tag `!integration`）

内存模拟实现，与 `pkg/lvs` 的 fake/linux 分离策略一致。

## 步骤 4：Reconciler 集成 SNAT 管理

**文件**: `pkg/lvs/reconciler.go`

1. `Reconciler` 新增 `snatMgr snat.Manager` 字段
2. `NewReconciler` 签名新增 `snatMgr` 参数
3. `Reconcile` 末尾：遍历 desiredConfigs，对 `FullNAT=true` 的 service 的每个 **健康** backend 构建 `SNATRule`（SnatIP 取自 `ServiceConfig.SnatIP`），调用 `snatMgr.Reconcile`

## 步骤 5：Server 层集成

**文件**: `pkg/server/server.go`

1. 初始化 `snat.NewManager()`，传递给 `NewReconciler`
2. `shutdown` 中调用 `snatMgr.Cleanup()`

## 步骤 6：补充测试

**新建文件**: `pkg/snat/manager_test.go` — 测试 fake Reconcile 增删逻辑

**文件**: `pkg/config/config_test.go`
- `TestValidate_SnatIPValid` / `TestValidate_SnatIPInvalid` / `TestValidate_SnatIPEmpty`
- `TestValidate_SnatIPWithoutFullNAT` — snat_ip 非空但 full_nat=false 时报错

**文件**: `pkg/lvs/reconciler_test.go`
- 测试 full_nat=true 时 SNAT 规则正确生成
- 测试 full_nat=false 时跳过 SNAT

## 步骤 7：更新示例配置和文档

**文件**: `examples/ezlb.yaml` — dns-service 添加 `full_nat: true` 和 `snat_ip: 10.0.0.3`

**文件**: `README.md`、`README_CN.md`
- 特性列表新增 FullNAT/SNAT 支持
- 配置参考中说明 `full_nat` 和 `snat_ip` 字段
- 说明在 iptables-nft 后端系统上自动兼容 nftables

## 涉及的文件清单

| 文件 | 操作 |
|------|------|
| `go.mod` | 修改：新增 coreos/go-iptables 依赖 |
| `pkg/config/config.go` | 修改：新增 FullNAT、SnatIP 字段和校验 |
| `pkg/config/config_test.go` | 修改：新增校验测试 |
| `pkg/snat/snat.go` | 新建：SNATRule 定义和 Manager 接口 |
| `pkg/snat/manager_linux.go` | 新建：Linux iptables 实现（coreos/go-iptables） |
| `pkg/snat/manager_fake.go` | 新建：非 Linux fake 实现 |
| `pkg/snat/manager_test.go` | 新建：SNAT 管理测试 |
| `pkg/lvs/reconciler.go` | 修改：集成 SNAT reconcile |
| `pkg/lvs/reconciler_test.go` | 修改：补充 SNAT 测试 |
| `pkg/server/server.go` | 修改：初始化/清理 SNAT Manager |
| `examples/ezlb.yaml` | 修改：添加 full_nat 和 snat_ip 示例 |
| `README.md` | 修改：更新文档 |
| `README_CN.md` | 修改：更新文档 |


updateAtTime: 2026/2/12 15:54:39

planId: 3f5bb0d4-f9b4-48ae-813c-4a2b9f29168f