### ezlb-unit-and-integration-tests ###
为 ezlb 项目的 5 个核心模块（config、lvs/types、lvs/manager、lvs/reconciler、healthcheck）添加详细的单元测试，并为 3 个核心联动流程（启动首次同步、配置热加载、健康状态变更）添加集成测试。


## 测试文件总览

| 测试文件 | 类型 | 测试目标 |
|---------|------|---------|
| `pkg/config/config_test.go` | 单元测试 | 配置加载、校验、默认值、热加载 |
| `pkg/lvs/types_test.go` | 单元测试 | 类型转换、Key 生成 |
| `pkg/lvs/manager_test.go` | 单元测试 | Manager CRUD 操作（基于 fakeHandle） |
| `pkg/lvs/reconciler_test.go` | 单元测试 | Reconciler diff 逻辑、健康过滤 |
| `pkg/healthcheck/checker_test.go` | 单元测试 | TCP 探测器 |
| `pkg/healthcheck/manager_test.go` | 单元测试 | 健康检查状态机、目标管理 |
| `pkg/server/server_integration_test.go` | 集成测试 | 模块间联动流程 |

---

## 第 1 步：config 模块单元测试

**文件**: `pkg/config/config_test.go`

### 1.1 Validate 函数测试

- **合法配置通过校验**: 完整合法的 Config 结构体，验证 Validate 返回 nil
- **空 services 列表**: 验证报错 "at least one service must be defined"
- **service name 为空**: 验证报错
- **service name 重复**: 两个 service 同名，验证报错 "duplicate service name"
- **listen 地址格式非法**: 如 "not-an-address"，验证报错
- **listen IP 非法**: 如 "abc:80"，验证报错
- **listen 端口为 0**: 验证报错
- **listen 地址重复**: 两个 service 监听同一地址，验证报错
- **protocol 为空时自动填充 tcp**: 验证 Validate 后 Protocol 被设为 "tcp"
- **protocol 不支持**: 如 "udp"，验证报错
- **scheduler 不支持**: 如 "random"，验证报错
- **scheduler 合法值**: 分别测试 "rr"、"wrr"、"lc" 均通过
- **health_check.interval 格式非法**: 如 "abc"，验证报错
- **health_check.timeout 格式非法**: 如 "xyz"，验证报错
- **health_check 禁用时不校验 interval/timeout**: enabled=false 且 interval 非法，验证通过
- **backends 为空**: 验证报错
- **backend address 为空**: 验证报错
- **backend address 格式非法**: 验证报错
- **backend IP 非法**: 验证报错
- **backend 端口为 0**: 验证报错
- **backend 地址重复**: 验证报错
- **backend weight <= 0**: 验证报错

### 1.2 HealthCheckConfig 方法测试

- **IsEnabled 默认值**: Enabled 为 nil 时返回 true
- **IsEnabled 显式 true/false**: 验证返回对应值
- **GetInterval 默认值**: Interval 为空时返回 5s
- **GetInterval 非法值**: 返回 5s
- **GetInterval 正常值**: 如 "10s" 返回 10s
- **GetTimeout 默认值/非法值/正常值**: 同上逻辑，默认 3s
- **GetFailCount 默认值**: <= 0 时返回 3
- **GetFailCount 正常值**: 如 5 返回 5
- **GetRiseCount 默认值**: <= 0 时返回 2
- **GetRiseCount 正常值**: 如 4 返回 4

### 1.3 Manager 加载测试

- **Load 合法 YAML 文件**: 创建临时 YAML 文件，验证 NewManager 成功且 GetConfig 返回正确内容
- **Load 不存在的文件**: 验证 NewManager 返回错误
- **Load 非法 YAML**: 验证 NewManager 返回错误
- **Load 校验失败的 YAML**: 如缺少 backends，验证 NewManager 返回错误

---

## 第 2 步：lvs/types 模块单元测试

**文件**: `pkg/lvs/types_test.go`（build tag `!linux`）

### 2.1 协议转换

- **protocolFromString("tcp")**: 返回 syscall.IPPROTO_TCP
- **protocolFromString("udp")**: 返回 syscall.IPPROTO_UDP
- **protocolFromString("unknown")**: 返回错误
- **protocolToString(IPPROTO_TCP)**: 返回 "tcp"
- **protocolToString(IPPROTO_UDP)**: 返回 "udp"
- **protocolToString(999)**: 返回 "unknown(999)"

### 2.2 地址族判定

- **addressFamilyFromIP IPv4**: 返回 AF_INET
- **addressFamilyFromIP IPv6**: 返回 AF_INET6
- **netmaskFromFamily AF_INET**: 返回 0xFFFFFFFF
- **netmaskFromFamily AF_INET6**: 返回 128

### 2.3 ServiceKey 生成

- **ServiceKeyFromConfig 正常**: 验证 Address/Port/Protocol 正确
- **ServiceKeyFromConfig 非法 listen**: 返回错误
- **ServiceKeyFromConfig 非法 port**: 返回错误
- **ServiceKeyFromConfig 非法 protocol**: 返回错误
- **ServiceKeyFromIPVS**: 验证从 Service 结构体正确生成 Key
- **ServiceKey.String()**: 验证格式 "ip:port/protocol"

### 2.4 DestinationKey 生成

- **DestinationKeyFromIPVS**: 验证正确生成
- **DestinationKey.String()**: 验证格式 "ip:port"

### 2.5 Config 到 IPVS 转换

- **ConfigToIPVSService 正常 TCP**: 验证所有字段正确映射
- **ConfigToIPVSService 非法 listen**: 返回错误
- **ConfigToIPVSService 非法 IP**: 返回错误
- **ConfigToIPVSService IPv6 地址**: 验证 AddressFamily 为 AF_INET6
- **ConfigToIPVSDestination 正常**: 验证字段映射，ConnectionFlags 为 Masq
- **ConfigToIPVSDestination 非法 address**: 返回错误

---

## 第 3 步：lvs/manager 模块单元测试

**文件**: `pkg/lvs/manager_test.go`（build tag `!linux`）

使用 fakeHandle 作为底层实现，测试 Manager 的封装逻辑。

- **CreateService 成功**: 验证 GetServices 能查到
- **CreateService 重复**: 验证返回错误
- **UpdateService 成功**: 验证 scheduler 变更生效
- **UpdateService 不存在**: 验证返回错误
- **DeleteService 成功**: 验证删除后 GetServices 为空
- **DeleteService 不存在**: 验证返回错误
- **CreateDestination 成功**: 验证 GetDestinations 能查到
- **UpdateDestination 成功**: 验证 weight 变更生效
- **DeleteDestination 成功**: 验证删除后为空
- **多 Service 多 Destination 组合操作**: 创建 2 个 service，各加 2 个 destination，验证隔离性

---

## 第 4 步：lvs/reconciler 模块单元测试

**文件**: `pkg/lvs/reconciler_test.go`（build tag `!linux`）

需要一个 mock HealthChecker 实现：

```go
type mockHealthChecker struct {
    status map[string]bool
}
func (m *mockHealthChecker) IsHealthy(address string) bool {
    healthy, ok := m.status[address]
    if !ok { return true }
    return healthy
}
```

### 4.1 首次 Reconcile（空 IPVS -> 创建）

- **单 service 单 backend**: 验证 IPVS 中创建了 1 个 service + 1 个 destination
- **单 service 多 backend**: 验证创建了多个 destination
- **多 service**: 验证创建了多个 service

### 4.2 幂等性

- **连续两次相同配置 Reconcile**: 第二次无变更，IPVS 状态不变

### 4.3 Service 层 Diff

- **新增 service**: 已有 A，新增 B，验证 B 被创建
- **删除 service**: 已有 A+B，期望只有 A，验证 B 被删除
- **更新 scheduler**: service 的 scheduler 从 rr 变为 wrr，验证更新

### 4.4 Destination 层 Diff

- **新增 backend**: service 下新增一个 backend，验证 destination 被创建
- **删除 backend**: service 下移除一个 backend，验证 destination 被删除
- **更新 weight**: backend 的 weight 变更，验证 destination 被更新

### 4.5 健康检查过滤

- **健康检查启用 + backend 不健康**: 验证不健康 backend 不出现在 IPVS 中
- **健康检查启用 + 全部健康**: 验证全部 backend 出现
- **健康检查禁用**: 验证所有 backend 均出现（不管 healthChecker 返回什么）
- **backend 从不健康恢复**: 先 Reconcile 剔除，再标记健康后 Reconcile，验证重新加入

### 4.6 错误处理

- **buildDesiredState 非法配置**: 如 listen 地址非法，验证返回错误

---

## 第 5 步：healthcheck 模块单元测试

### 5.1 checker_test.go

**文件**: `pkg/healthcheck/checker_test.go`

- **TCPChecker 连接成功**: 启动本地 TCP listener，验证 Check 返回 nil
- **TCPChecker 连接失败**: 对不存在的端口 Check，验证返回错误
- **TCPChecker 超时**: 使用极短超时 + 不可达地址，验证返回错误

### 5.2 manager_test.go

**文件**: `pkg/healthcheck/manager_test.go`

需要一个 mock Checker：

```go
type mockChecker struct {
    results map[string]error
}
func (m *mockChecker) Check(address string) error {
    return m.results[address]
}
```

由于 Manager 内部直接创建 TCPChecker，需要通过以下方式测试：

- **IsHealthy 未知地址**: 返回 true（默认健康）
- **UpdateTargets 注册 backend**: 验证 backend 被注册，初始状态为健康
- **UpdateTargets 移除 backend**: 先注册再移除，验证状态被清理
- **UpdateTargets 禁用健康检查的 service**: 验证不创建检查 goroutine，IsHealthy 返回 true
- **UpdateTargets 启用->禁用转换**: 验证停止检查
- **handleCheckResult 连续失败达到阈值**: 直接调用 handleCheckResult 模拟连续失败，验证状态变为不健康
- **handleCheckResult 连续成功恢复**: 模拟不健康后连续成功达到 riseCount，验证恢复健康
- **handleCheckResult 触发 onChange**: 验证状态变化时 onChange 回调被调用
- **handleCheckResult 未变化不触发 onChange**: 验证状态未变时不调用回调
- **Stop 清理所有状态**: 验证 Stop 后 statuses 和 services 为空

> 注意：由于 `handleCheckResult` 是私有方法，测试文件需放在 `healthcheck` 包内（同包测试），以便直接访问内部状态和方法。同时需要将 `serviceCheckConfig` 在测试中手动构造注入。

---

## 第 6 步：集成测试

**文件**: `pkg/server/server_integration_test.go`（build tag `!linux`）

集成测试通过组装真实模块（config.Manager + fakeHandle 的 lvs.Manager + healthcheck.Manager + Reconciler）验证端到端流程。

### 6.1 流程 A - 启动时首次同步

1. 准备合法 YAML 配置文件（2 个 service，各 2 个 backend）
2. 创建 Server（内部使用 fakeHandle）
3. 调用 RunOnce
4. 通过 lvs.Manager.GetServices 验证 IPVS 中创建了 2 个 service
5. 通过 lvs.Manager.GetDestinations 验证每个 service 下有 2 个 destination

### 6.2 流程 B - 配置热加载触发 Reconcile

1. 准备初始 YAML 配置（1 个 service，2 个 backend）
2. 启动 Server.Run（后台 goroutine）
3. 验证初始 IPVS 状态正确
4. 修改 YAML 文件：新增 1 个 backend、修改 scheduler
5. 等待配置变更事件传播
6. 验证 IPVS 中 service 的 scheduler 已更新、新 backend 已添加

### 6.3 流程 C - 健康状态变更触发 Reconcile

1. 准备配置（1 个 service，2 个 backend，健康检查启用）
2. 组装模块，手动控制 healthcheck.Manager 的状态
3. 首次 Reconcile：全部健康，验证 2 个 destination
4. 将 1 个 backend 标记为不健康，触发 Reconcile
5. 验证 IPVS 中只剩 1 个 destination
6. 将该 backend 恢复健康，触发 Reconcile
7. 验证 IPVS 中恢复为 2 个 destination

### 6.4 流程 D - 优雅退出

1. 启动 Server.Run
2. 取消 context
3. 验证 healthcheck 已 Stop、lvs.Manager 已 Close

> 注意：集成测试中需要将 `Server` 的内部字段暴露或提供辅助方法以便验证 IPVS 状态。可以考虑在 `Server` 上添加 `GetLVSManager()` 等测试辅助方法，或者在测试中直接组装各模块而不通过 `NewServer`。

---

## 第 7 步：运行与验证

1. 在项目根目录执行 `go test ./... -v` 确保所有测试通过
2. 检查 build tag `!linux` 确保在 macOS 上使用 fakeHandle
3. 执行 `go vet ./...` 确保无静态分析问题


updateAtTime: 2026/2/8 08:29:25

planId: 703bc700-da14-42dc-955d-b601db299503